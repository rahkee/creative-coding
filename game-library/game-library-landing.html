<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Library Landing</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-snap-type: y mandatory;
        }

        .section {
            height: 100vh;
            display: grid;
            grid-template-columns: 1fr;
            grid-template-rows: 1fr;
            scroll-snap-align: start;
            scroll-snap-stop: always;
        }

        .section > * {
            grid-column: 1;
            grid-row: 1;
        }

        .section img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #starsCanvas {
            width: 40%;
            height: 50%;
            pointer-events: none;
            justify-self: center;
            align-self: start;
        }

        #firefliesCanvas {
            width: 100%;
            height: 75%;
            pointer-events: none;
            justify-self: center;
            align-self: start;
        }

        .hero-content {
            justify-self: center;
            align-self: center;
            text-align: center;
            color: white;
            width: 50%;
            min-width: 620px;
            z-index: 30;
            padding: 2rem;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }

        .hero-content h1 {
            font-size: 3.8rem;
            font-weight: 600;
            margin-bottom: 0;
            color: white;
        }

        .hero-content h2 {
            font-size: 1.8rem;
            font-weight: 400;
            margin-bottom: 1rem;
            color: rgba(255, 255, 255, 0.9);
        }

        .hero-content p {
            font-size: 0.825rem;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.8);
            text-align: left;
            margin-bottom: 2rem;
        }

        .cta-container {
            position: relative;
            display: inline-block;
        }

        .button-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 1;
        }

        .cta-button {
            display: inline-block;
            padding: 1.6rem 3.2rem;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            color: #ffffff;
            text-decoration: none;
            font-weight: 600;
            font-size: 1.1rem;
            position: relative;
            z-index: 2;
            border-radius: 8px;
            box-shadow: 
                0 8px 16px rgba(0, 0, 0, 0.15),
                0 4px 8px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            letter-spacing: 0.5px;
        }

        .cta-button:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 
                0 12px 24px rgba(0, 0, 0, 0.2),
                0 6px 12px rgba(0, 0, 0, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(15px);
        }

        .cta-container:hover .button-canvas {
            filter: brightness(1.1) contrast(1.05);
        }

        .sparkles-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 3;
        }

        .sparkle {
            position: absolute;
            width: 16px;
            height: 16px;
            color: #FFD700;
            opacity: 0;
            transform: scale(0) rotate(0deg);
            transition: all 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .sparkle-1 {
            top: -10px;
            left: 20%;
            transition-delay: 0.1s;
        }

        .sparkle-2 {
            top: -15px;
            right: 25%;
            transition-delay: 0.2s;
        }

        .sparkle-3 {
            top: 50%;
            left: -20px;
            transition-delay: 0.15s;
        }

        .sparkle-4 {
            top: 50%;
            right: -20px;
            transition-delay: 0.25s;
        }

        .sparkle-5 {
            bottom: -10px;
            left: 30%;
            transition-delay: 0.3s;
        }

        .sparkle-6 {
            bottom: -15px;
            right: 20%;
            transition-delay: 0.05s;
        }

        .cta-container:hover .sparkle {
            opacity: 1;
            transform: scale(1) rotate(180deg);
            animation: sparkle-twinkle 2s ease-in-out infinite;
        }

        @keyframes sparkle-twinkle {
            0%, 100% { 
                opacity: 1; 
                transform: scale(1) rotate(180deg);
            }
            50% { 
                opacity: 0.3; 
                transform: scale(1.2) rotate(270deg);
            }
        }
    </style>
</head>
<body>
    <!-- Row 1 -->
    <section class="section">
        <img src="570f9e19-4b51-4ccc-a1a5-d2cd8a2c0fc8.png" alt="Forest Night">
        <canvas id="starsCanvas"></canvas>
        <div class="hero-content">
            <h1>Wonder to Wisdom</h1>
            <h2>From Play to Mastery—The Natural Route</h2>
            <p>Research shows that the brain learns best when engaged and emotionally invested. Play activates key areas involved in memory, attention, and motivation—making learning more effective and enjoyable. When kids have fun, they stick with challenges and build lasting skills. Our games make learning feel like play—because joyful learning is powerful learning.</p>
            <div class="cta-container">
                <canvas id="buttonCanvas" class="button-canvas"></canvas>
                <a href="#" class="cta-button">Sign up for Free</a>
                <div class="sparkles-container">
                    <svg class="sparkle sparkle-1" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 0L14.59 8.41L23 11L14.59 13.59L12 22L9.41 13.59L1 11L9.41 8.41L12 0Z"/>
                    </svg>
                    <svg class="sparkle sparkle-2" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 0L14.59 8.41L23 11L14.59 13.59L12 22L9.41 13.59L1 11L9.41 8.41L12 0Z"/>
                    </svg>
                    <svg class="sparkle sparkle-3" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 0L14.59 8.41L23 11L14.59 13.59L12 22L9.41 13.59L1 11L9.41 8.41L12 0Z"/>
                    </svg>
                    <svg class="sparkle sparkle-4" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 0L14.59 8.41L23 11L14.59 13.59L12 22L9.41 13.59L1 11L9.41 8.41L12 0Z"/>
                    </svg>
                    <svg class="sparkle sparkle-5" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 0L14.59 8.41L23 11L14.59 13.59L12 22L9.41 13.59L1 11L9.41 8.41L12 0Z"/>
                    </svg>
                    <svg class="sparkle sparkle-6" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 0L14.59 8.41L23 11L14.59 13.59L12 22L9.41 13.59L1 11L9.41 8.41L12 0Z"/>
                    </svg>
                </div>
            </div>
        </div>
    </section>

    <!-- Row 2 -->
    <section class="section">
        <img src="30f2d5d8-f05c-4025-b665-9239dfb8730f.png" alt="Campfire">
        <canvas id="firefliesCanvas"></canvas>
    </section>

    <!-- Row 3 (Footer) -->
    <section class="section">
        <img src="85444bf1-a2a2-4497-b75f-2aac5b75570a.png" alt="Cave">
    </section>

    <script>
        const canvas = document.getElementById('starsCanvas');
        const ctx = canvas.getContext('2d');

        // Set canvas size
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }
        
        // Star properties matching the image colors
        const stars = [];
        const starColors = ['#E6D7A3', '#FFFFFF', '#FFF8DC', '#F0E68C']; // Muted golden, white, cream tones

        // Create stars across the entire canvas with size based on vertical position
        function createStars() {
            // Ensure canvas size is set before creating stars
            resizeCanvas();
            
            const numStars = 66;
            for (let i = 0; i < numStars; i++) {
                const starType = Math.random() < 0.3 ? 'circle' : 'starburst';
                const y = Math.random() * canvas.height;
                
                // Size decreases towards bottom (depth effect)
                const sizeMultiplier = 1 - (y / canvas.height) * 0.7; // 30% size at bottom, 100% at top
                
                const baseSize = starType === 'circle' ? 
                    (Math.random() * 1 + 0.5) * sizeMultiplier : // Small circles with depth
                    (Math.random() * 3 + 1) * 1.25 * 1.25 * sizeMultiplier; // Starbursts 25% larger again
                
                // Add padding to ensure stars don't get cut off at edges
                const padding = Math.max(baseSize, 5); // Use star size or minimum 5px padding
                
                stars.push({
                    x: padding + Math.random() * (canvas.width - padding * 2),
                    y: Math.max(padding, Math.min(y, canvas.height - padding)),
                    size: baseSize,
                    opacity: Math.random() * 0.8 + 0.2,
                    twinkleSpeed: (Math.random() * 0.01 + 0.005) * (0.75 + Math.random() * 0.8125), // Random range: 75% to 156.25% of base speed
                    color: starColors[Math.floor(Math.random() * starColors.length)],
                    type: starType,
                    spikes: Math.floor(Math.random() * 3) + 4, // 4-6 spikes for starbursts
                    rotation: Math.random() * Math.PI * 2
                });
            }
        }

        // Draw starburst shape
        function drawStarburst(x, y, size, spikes, rotation) {
            const outerRadius = size;
            const innerRadius = size * 0.4;
            
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);
            
            ctx.beginPath();
            for (let i = 0; i < spikes * 2; i++) {
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const angle = (i * Math.PI) / spikes;
                const px = Math.cos(angle) * radius;
                const py = Math.sin(angle) * radius;
                
                if (i === 0) {
                    ctx.moveTo(px, py);
                } else {
                    ctx.lineTo(px, py);
                }
            }
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        // Animate stars
        function animateStars() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            stars.forEach(star => {
                // Update opacity for twinkling effect
                star.opacity += star.twinkleSpeed;
                if (star.opacity >= 1 || star.opacity <= 0.2) {
                    star.twinkleSpeed *= -1;
                }

                // Set drawing properties
                ctx.globalAlpha = star.opacity;
                ctx.fillStyle = star.color;
                ctx.shadowColor = star.color;
                ctx.shadowBlur = star.size * 1.5;

                // Draw star based on type
                if (star.type === 'circle') {
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    drawStarburst(star.x, star.y, star.size, star.spikes, star.rotation);
                }

                ctx.shadowBlur = 0;
            });

            requestAnimationFrame(animateStars);
        }

        // Initialize after a short delay to ensure canvas is properly sized
        setTimeout(() => {
            createStars();
            animateStars();
        }, 100);

        // Recreate stars when window resizes
        window.addEventListener('resize', () => {
            stars.length = 0;
            setTimeout(createStars, 50); // Small delay to ensure resize is complete
        });

        // ORNATE BUTTON CANVAS DESIGN
        const buttonCanvas = document.getElementById('buttonCanvas');
        const buttonCtx = buttonCanvas.getContext('2d');

        function initButtonCanvas() {
            const button = document.querySelector('.cta-button');
            const rect = button.getBoundingClientRect();
            
            // Set canvas size to match button with extra space for decorations
            buttonCanvas.width = rect.width + 40;
            buttonCanvas.height = rect.height + 40;
            buttonCanvas.style.width = (rect.width + 40) + 'px';
            buttonCanvas.style.height = (rect.height + 40) + 'px';
            buttonCanvas.style.left = '-20px';
            buttonCanvas.style.top = '-20px';
            
            drawOrnateDecorations();
        }

        function drawOrnateDecorations() {
            const ctx = buttonCtx;
            const w = buttonCanvas.width;
            const h = buttonCanvas.height;
            
            ctx.clearRect(0, 0, w, h);
            
            // Create ornate corner decorations
            drawCornerOrnaments(ctx, w, h);
            
            // Draw decorative border elements
            drawDecorativeBorder(ctx, w, h);
            
            // Add filigree details
            drawFiligree(ctx, w, h);
            
            // Add subtle pattern overlay
            drawPatternOverlay(ctx, w, h);
        }

        function drawCornerOrnaments(ctx, w, h) {
            ctx.strokeStyle = 'rgba(218, 165, 32, 0.6)'; // Golden color
            ctx.fillStyle = 'rgba(218, 165, 32, 0.3)';
            ctx.lineWidth = 1.5;
            
            // Top-left ornament
            drawOrnament(ctx, 25, 25, 15, 0);
            
            // Top-right ornament
            drawOrnament(ctx, w - 25, 25, 15, Math.PI / 2);
            
            // Bottom-right ornament
            drawOrnament(ctx, w - 25, h - 25, 15, Math.PI);
            
            // Bottom-left ornament
            drawOrnament(ctx, 25, h - 25, 15, -Math.PI / 2);
        }

        function drawOrnament(ctx, x, y, size, rotation) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);
            
            // Draw intricate corner piece
            ctx.beginPath();
            
            // Central flower-like shape
            for (let i = 0; i < 8; i++) {
                const angle = (i * Math.PI) / 4;
                const r1 = size * 0.6;
                const r2 = size * 0.3;
                
                const x1 = Math.cos(angle) * r1;
                const y1 = Math.sin(angle) * r1;
                const x2 = Math.cos(angle + Math.PI / 8) * r2;
                const y2 = Math.sin(angle + Math.PI / 8) * r2;
                
                if (i === 0) ctx.moveTo(x1, y1);
                ctx.quadraticCurveTo(x2, y2, 
                    Math.cos(angle + Math.PI / 4) * r1, 
                    Math.sin(angle + Math.PI / 4) * r1);
            }
            
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Add small decorative dots
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI) / 2 + Math.PI / 4;
                const dotX = Math.cos(angle) * size * 0.8;
                const dotY = Math.sin(angle) * size * 0.8;
                
                ctx.beginPath();
                ctx.arc(dotX, dotY, 1.5, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }

        function drawDecorativeBorder(ctx, w, h) {
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.4)'; // Gold
            ctx.lineWidth = 1;
            
            // Top border decoration
            drawBorderPattern(ctx, 40, 15, w - 80, true);
            
            // Bottom border decoration
            drawBorderPattern(ctx, 40, h - 15, w - 80, true);
            
            // Left border decoration
            drawBorderPattern(ctx, 15, 40, h - 80, false);
            
            // Right border decoration
            drawBorderPattern(ctx, w - 15, 40, h - 80, false);
        }

        function drawBorderPattern(ctx, startX, startY, length, horizontal) {
            ctx.save();
            
            if (!horizontal) {
                ctx.translate(startX, startY);
                ctx.rotate(Math.PI / 2);
                startX = 0;
                startY = 0;
            }
            
            // Create repeating decorative pattern
            const segments = Math.floor(length / 20);
            for (let i = 0; i < segments; i++) {
                const x = startX + (i * 20);
                const y = startY;
                
                // Small decorative wave
                ctx.beginPath();
                ctx.moveTo(x, y - 3);
                ctx.quadraticCurveTo(x + 5, y - 6, x + 10, y - 3);
                ctx.quadraticCurveTo(x + 15, y, x + 20, y - 3);
                ctx.stroke();
                
                // Add small ornamental dots
                if (i % 2 === 0) {
                    ctx.beginPath();
                    ctx.arc(x + 10, y - 8, 1, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            ctx.restore();
        }

        function drawFiligree(ctx, w, h) {
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
            ctx.lineWidth = 0.8;
            
            // Draw delicate swirls near corners
            drawSwirl(ctx, 35, 35, 8, 1);
            drawSwirl(ctx, w - 35, 35, 8, -1);
            drawSwirl(ctx, w - 35, h - 35, 8, 1);
            drawSwirl(ctx, 35, h - 35, 8, -1);
        }

        function drawSwirl(ctx, x, y, radius, direction) {
            ctx.save();
            ctx.translate(x, y);
            
            ctx.beginPath();
            for (let i = 0; i <= 50; i++) {
                const angle = (i / 50) * Math.PI * 3 * direction;
                const r = radius * (1 - i / 50);
                const px = Math.cos(angle) * r;
                const py = Math.sin(angle) * r;
                
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();
            
            ctx.restore();
        }

        function drawPatternOverlay(ctx, w, h) {
            // Subtle texture overlay
            ctx.fillStyle = 'rgba(255, 215, 0, 0.05)';
            
            // Create diamond pattern
            for (let x = 0; x < w; x += 8) {
                for (let y = 0; y < h; y += 8) {
                    if ((x + y) % 16 === 0) {
                        ctx.beginPath();
                        ctx.moveTo(x + 4, y);
                        ctx.lineTo(x + 8, y + 4);
                        ctx.lineTo(x + 4, y + 8);
                        ctx.lineTo(x, y + 4);
                        ctx.closePath();
                        ctx.fill();
                    }
                }
            }
        }

        // Initialize button canvas after a delay to ensure button is rendered
        setTimeout(() => {
            initButtonCanvas();
        }, 200);

        // Redraw on window resize
        window.addEventListener('resize', () => {
            setTimeout(initButtonCanvas, 100);
        });

        // FIREFLIES ANIMATION
        const firefliesCanvas = document.getElementById('firefliesCanvas');
        const firefliesCtx = firefliesCanvas.getContext('2d');

        // Set fireflies canvas size
        function resizeFirefliesCanvas() {
            firefliesCanvas.width = firefliesCanvas.offsetWidth;
            firefliesCanvas.height = firefliesCanvas.offsetHeight;
        }

        const fireflies = [];
        const firefliesColors = ['#FFD700', '#FFA500', '#FFFF00', '#90EE90']; // Golden, orange, yellow, light green

                 // Firefly class
         class Firefly {
             constructor(startDelay = 0) {
                 this.reset();
                 this.visible = startDelay === 0; // Some start visible, others start hidden
                 this.opacity = startDelay === 0 ? 0 : 0;
                 this.fadeIn = startDelay === 0;
                 this.lifetime = Math.random() * 3000 + 2000; // Live for 2-5 seconds
                 this.age = startDelay === 0 ? 0 : this.lifetime; // Stagger initial ages
                 this.nextAppearance = startDelay === 0 ? 0 : Date.now() + startDelay;
             }

                         reset() {
                 this.x = Math.random() * firefliesCanvas.width;
                 
                 // Weighted distribution: more fireflies at top, fewer at bottom
                 // Using power function to create non-linear distribution
                 const randomValue = Math.random();
                 const weightedValue = Math.pow(randomValue, 2); // Square makes it favor smaller values (top)
                 this.y = weightedValue * firefliesCanvas.height;
                 this.vx = (Math.random() - 0.5) * 1.5; // Reduced velocity by 25%: -0.75 to 0.75
                 this.vy = (Math.random() - 0.5) * 1.5;
                 this.size = Math.random() * 3 + 2; // Size 2-5
                 this.color = firefliesColors[Math.floor(Math.random() * firefliesColors.length)];
                 this.pulseSpeed = (Math.random() * 0.1 + 0.05) * 0.75; // Reduced pulsing speed by 25%
                 this.pulsePhase = Math.random() * Math.PI * 2;
                 
                 // Circular motion properties
                 this.circularForce = Math.random() * 0.02 + 0.01; // Reduced circular force for wider circles
                 this.rotationDirection = Math.random() < 0.5 ? 1 : -1; // Clockwise or counter-clockwise
                 this.centerX = this.x; // Center point for circular motion
                 this.centerY = this.y;
                 this.centerDrift = 0.3; // How much the center point drifts
                 this.rotationChangeTimer = Math.random() * 2000 + 1000; // Change direction every 1-3 seconds
                 this.timeSinceRotationChange = 0;
             }

                         update(deltaTime) {
                 if (this.visible) {
                     // Update rotation change timer
                     this.timeSinceRotationChange += deltaTime;
                     
                     // Switch rotation direction periodically
                     if (this.timeSinceRotationChange >= this.rotationChangeTimer) {
                         this.rotationDirection *= -1; // Flip direction
                         this.rotationChangeTimer = Math.random() * 2000 + 1000; // Reset timer for 1-3 seconds
                         this.timeSinceRotationChange = 0;
                     }

                     // Apply circular motion by rotating velocity vector
                     const currentAngle = Math.atan2(this.vy, this.vx);
                     const newAngle = currentAngle + (this.circularForce * this.rotationDirection);
                     const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                     
                     this.vx = Math.cos(newAngle) * speed;
                     this.vy = Math.sin(newAngle) * speed;

                     // Drift the center point slowly for varied circular paths
                     this.centerX += (Math.random() - 0.5) * this.centerDrift;
                     this.centerY += (Math.random() - 0.5) * this.centerDrift;

                     // Move firefly
                     this.x += this.vx;
                     this.y += this.vy;

                     // Occasional random direction changes (reduced frequency for more circular motion)
                     if (Math.random() < 0.008) { // Reduced from 0.02 to 0.008
                         this.vx += (Math.random() - 0.5) * 0.3; // Reduced force
                         this.vy += (Math.random() - 0.5) * 0.3;
                         
                         // Limit speed (reduced by 25%)
                         const newSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                         if (newSpeed > 1.5) {
                             this.vx = (this.vx / newSpeed) * 1.5;
                             this.vy = (this.vy / newSpeed) * 1.5;
                         }
                     }

                    // Gentle steering away from boundaries (more natural)
                    const margin = 20; // Distance from edge to start steering
                    const steerForce = 0.1; // How strong the steering is
                    
                    // Steer away from left edge
                    if (this.x < margin) {
                        this.vx += steerForce * (margin - this.x) / margin;
                    }
                    // Steer away from right edge
                    if (this.x > firefliesCanvas.width - margin) {
                        this.vx -= steerForce * (this.x - (firefliesCanvas.width - margin)) / margin;
                    }
                    // Steer away from top edge
                    if (this.y < margin) {
                        this.vy += steerForce * (margin - this.y) / margin;
                    }
                    // Steer away from bottom edge
                    if (this.y > firefliesCanvas.height - margin) {
                        this.vy -= steerForce * (this.y - (firefliesCanvas.height - margin)) / margin;
                    }
                    
                    // Keep within bounds as backup (but shouldn't be needed with steering)
                    this.x = Math.max(5, Math.min(firefliesCanvas.width - 5, this.x));
                    this.y = Math.max(5, Math.min(firefliesCanvas.height - 5, this.y));

                    // Update age and opacity
                    this.age += deltaTime;
                    
                    if (this.fadeIn && this.opacity < 1) {
                        this.opacity += 0.02;
                        if (this.opacity >= 1) this.fadeIn = false;
                    } else if (!this.fadeIn && this.age > this.lifetime * 0.7) {
                        // Start fading out in last 30% of lifetime
                        this.opacity -= 0.015;
                        if (this.opacity <= 0) {
                            this.visible = false;
                            this.nextAppearance = Date.now() + Math.random() * 4000 + 1000; // Reappear in 1-5 seconds
                        }
                    }

                    // Update pulse phase
                    this.pulsePhase += this.pulseSpeed;
                } else {
                    // Check if it's time to reappear
                    if (Date.now() >= this.nextAppearance) {
                        this.reset();
                        this.visible = true;
                        this.opacity = 0;
                        this.fadeIn = true;
                        this.age = 0;
                    }
                }
            }

            draw() {
                if (!this.visible || this.opacity <= 0) return;

                const pulseBrightness = 0.5 + 0.5 * Math.sin(this.pulsePhase);
                const currentOpacity = this.opacity * pulseBrightness;

                firefliesCtx.save();
                firefliesCtx.globalAlpha = currentOpacity;
                
                // Draw glow effect
                firefliesCtx.shadowColor = this.color;
                firefliesCtx.shadowBlur = this.size * 3;
                firefliesCtx.fillStyle = this.color;
                
                firefliesCtx.beginPath();
                firefliesCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                firefliesCtx.fill();
                
                // Inner bright core
                firefliesCtx.shadowBlur = 0;
                firefliesCtx.fillStyle = '#FFFFFF';
                firefliesCtx.beginPath();
                firefliesCtx.arc(this.x, this.y, this.size * 0.3, 0, Math.PI * 2);
                firefliesCtx.fill();
                
                firefliesCtx.restore();
            }
        }

                 // Create fireflies
         function createFireflies() {
             resizeFirefliesCanvas();
             fireflies.length = 0;
             
             const numFireflies = 21; // Reduced by 33% for optimal balance
             for (let i = 0; i < numFireflies; i++) {
                 // Stagger fireflies: half start visible, half start with delays
                 const startDelay = i < numFireflies / 2 ? 0 : Math.random() * 3000 + 1000;
                 fireflies.push(new Firefly(startDelay));
             }
         }

        // Animate fireflies
        let lastTime = 0;
        function animateFireflies(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            firefliesCtx.clearRect(0, 0, firefliesCanvas.width, firefliesCanvas.height);

            fireflies.forEach(firefly => {
                firefly.update(deltaTime);
                firefly.draw();
            });

            requestAnimationFrame(animateFireflies);
        }

        // Initialize fireflies after a delay
        setTimeout(() => {
            createFireflies();
            animateFireflies(0);
        }, 200);

        // Recreate fireflies when window resizes
        window.addEventListener('resize', () => {
            setTimeout(createFireflies, 100);
        });
    </script>
</body>
</html> 